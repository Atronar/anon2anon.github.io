==== Чат ====
10:29 Dead_Moroz: iTunes вышел https://yayponies.no/videos/torrents/YP-1T-06x24.mkv.torrent
15:31 mimimi: ща двину
16:09 mimimi: http://files.sunnysubs.com/files/Sub_MLPFiM_S06E24_iTunes_English.ass
16:09 mimimi: https://files.sunnysubs.com/files/Sub_MLPFiM_S06E24_iTunes_Russian.ass
16:16 Dead_Moroz: спасибо
16:49 u0: mimimi, а сколько примерно времени у тебя занимает передвигание сабов с одного рипа на другой?
17:17 Wolfram: у себя не засекал, но где-то 5-10 минут уходит по-моему
17:20 Wolfram: у меня есть ощущение, что двигать тайминг несложно вообще автоматически, ориентируясь на похожесть звуковых дорожек, но загуглить готовое решение у меня не получилось
17:25 Wolfram: в основном гугл выдаёт вопросы на каких-то форумах в стиле "можно ли по данному тексту распознавать, где конкретно в видео этот текст говорится и сделать тайминг", ну это проще, чем распознавать речь с нуля, но всё равно хардкорно, а вот двигать тайминг, если у нас есть готовые звуковые дорожки от двух рипов и готовый тайминг к одному должно быть гораздо проще
17:32 Wolfram: Джо, на Табуне ДМ-ссыль на предыдущую серию, а не на эту
17:48 u0: Классический способ найти соответствие (alignment) между двумя последовательностями — Needleman–Wunsch algorithm. Но времени это занимает Θ(n^2*k), где n — количество элементов последовательности (с временным разрешением 10 мс получается около 140000 элементов на 23 минуты), k — разрешение по частоте (допустим, 24).
В итоге — около 460*10^9 операций. А для двухчасового фильма — 12*10^12.
Вот я и думаю, стоит ли попытаться это реализовать.
17:56 mimimi: >u0: mimimi, а сколько примерно времени у тебя занимает передвигание сабов с одного рипа на другой?
довольно быстро, передвигать надо после опенинга, на 8 и 15 минутах
17:56 Wolfram: можно воспользоваться тем, что сдвиги небольшие, и сравнивать кусочки небольшой длины друг с другом, например, для каждой строки субтитров взять 10-секундный интервал видео, центром которого она является, и сравнить с соответствующим интервалом другого видео - скорее всего, мы установим, насколько нужно сдвинуть эту строку
17:56 mimimi: три точки, стабильно, во время рекламы
17:58 Wolfram: тогда у нас асимптотика будет порядка Θ(n*m*k), где m - длина того самого интервала
18:02 mimimi: https://files.sunnysubs.com/files/comparison_s06e24.html сравнялка подъехала.
18:04 mimimi: >Я планирую догнать Твайлайт в книгах про Дэринг Ду,
18:04 mimimi: ДОГОНЯЙ ЕЁ СУКУ
18:04 Васуа: http://i.imgur.com/weT5dhz.png lol
18:04 Васуа: даже хз, кто больше соснул
18:05 mimimi: традиционно соснули все
18:05 Wolfram: >даже хз, кто больше соснул
ага, доки-то как раз смысл оригинала не проебали)
18:06 mimimi: доооооооооо
18:06 Васуа: сарказм?
18:07 mimimi: >и заночевать с Пинки Пай!
чую, шутка про "переспать с Пинки" была актуальна не только у нас
18:07 Wolfram: эм, нет, несмотря на кривоту построения фразы, вполне понятно, что они хотели сказать
18:08 mimimi: > Ещё увидимся, девочки!
fuf
18:08 mimimi: ага
18:13 Wolfram: >Вэйпор Трэил
мастера транслитерации
18:17 Wolfram: >Летая вместе, мы дополняли друг друга!
18:20 u0: Wolfram, да, это примерно то, что когда-то делал Cactus. Но, во-первых, этот алгоритм не учитывает порядок событий. Оптимальная позиция события в пределах 10 секунд может не совпасть с оптимальной позицией между предыдущим и следующим событиями. И смежные события могут превратьться в накладывающиеся. А во-вторых, он откажется работать с двумя рипами, в одном из которых, например, вырезан опенинг.
18:21 mimimi: > Её крыло было под ним!
18:22 mimimi: >Решить её, не говоря им.
ну бляяяя
18:24 mimimi: >а, блин.
вот повидло!
18:28 Wolfram: со смежными событиями проблема не выглядит очень большой: после расчёта сдвигов для каждого события можно найти длинные куски последовательных событий с примерно одинаковыми сдвигами: это и будут участки между двумя вырезками рекламы; на них просто усредняем сдвиги по всем событиям и двигаем все на одно и то же число
18:31 Wolfram: с вырезанными кусками надо думать
18:33 Wolfram: мм, но мне бы сначала разобраться в сути того алгоритма
18:45 Wolfram: алгоритм простой, но, насколько я понял, чтобы восстановить соответствие, нужно ещё и Θ(n^2) памяти
18:47 u0: Не, матрица — это для наглядности. На самом деле достаточно хранить только две строчки — обрабатываемую и предыдущую.
18:51 Wolfram: нет, ну вот останется у тебя только последняя строчка, из неё ты конечно получилось цену разности между последовательностями, а как узнать после этого, какие преобразования надо совершить, чтобы достичь такой цены? по-моему, для этого придётся сохранить всю матрицу, и в каждой ячейке хранить, какая из трёх соседних дала наилучший результат, и в конце пройтись по таким ссылкам
18:58 u0: Да, точно. Это нетривиально.
Но таки возможно:
> Hirschberg's algorithm is a clever modification of the Needleman-Wunsch Algorithm which still takes O(nm) time, but needs only O(min{n,m}) space.
19:21 Wolfram: Окей, ясно, с памятью проблем не будет. Но всё-таки так извращаться не обязательно, можно воспользоваться тем, что вставок внутри события не бывает. Если мы событие (кусок аудиодорожки из исходного рипа) разбили на m отрезков длины по сотой доле секунды, а у другого рипа вся видеодорожка состоит из n таких отрезков, то мы можем просто перебрать все сдвиги события на время от 0 до n-m сотых, и посчитать разницу аудиодорожек при этих сдвигах в месте, куда сдвинули, искомым сдвигом будет минимальный по сумме отклонений
19:22 Wolfram: это даст ту же асимптотику Θ((n-m)m)
19:28 Wolfram: А чтобы ускорить этот метод, можно сделать следующее: допустим, мы уже поняли, что событие c номером K лучше всего сдвигать на A сотых секунды. После этого мы пытаемся и событие K+1 сдвинуть на A, и, возможно, на небольшое количество соседних с A значений. Если при одном из этих сдвигов получается устраивающая нас разность (меньше некоторого порога), то мы радуемся, считаем, что между этими событиями рекламы не было, и присваиваем событию K+1 сдвиг A или один из соседних
19:29 Wolfram: в конце такой цепочки без рекламы можно усреднить все сдвиги
19:29 Wolfram: если же у нас не получается, то K+1-е событие мы тестируем по полной программе для больших сдвигов
19:46 u0: Да, в большинстве случаев это должно сработать.
Но что, если событие К попало совсем не в то место? Скажем, на 10 минут позже. Или даже не одно событие, а целая цепочка. В аудиодорожке могут быть повторяющиеся фрагменты. Особенно если это серия о путешествиях во времени.
19:58 Wolfram: Если событие K-1 попало правильно, и между K-1 и K-м не было рекламы, то мы навряд ли ошибёмся при установлении соответствия для K-го. Т.е. реальная опасность промахнуться есть у 1-го события и у каждого события после рекламы, ну и ещё есть опасность, что по каким-то причинам наш порог для определения правдоподобности отсутствия рекламы оказался слишком мал, сейчас подумаю, как со всем этим бороться
20:44 Wolfram: 417
20:46 Wolfram: что-то подозреваю, что на нормальную реализацию уйдёт больше времени, чем суммарно потратят таймеры на сдвиг всех оставшихся серий)
20:58 Night Shadow: Прочитал перевод Доктора, так заорал.
21:06 mimimi: давай зажигай
21:15 u0: Wolfram, если придумать и реализовать более-менее универсальный алгоритм, можно предложить встроить его в Aegisub. Это принесёт пользу не только нашим таймерам.
Авторы Aegisub уже 7 лет планируют это сделать: http://devel.aegisub.org/ticket/1043
21:26 Wolfram: ок, понятно, я попробую в ближайшее время сформулировать весь алгоритм более последовательно и ясно, чтобы было понятно, что я требую от представления аудио в виде массива, и можно было проверить на практике, выполняются ли эти требования, потому что пока я придумываю какой-то алгоритм совершенно вслепую, т.е. я не очень представляю, насколько реально звукодорожки от разных рипов, сдвинутые в пределах одной сотой секунды, могут отличаться
October 17, 2016
0:31 u0: http://wiki.audacityteam.org/wiki/Proposal_Audio_Diff — а авторы Audacity больше 8 лет планируют.
Видимо, для общего случая это в самом деле непростая задача.
1:03 nwb: Wolfram: > что-то подозреваю, что на нормальную реализацию уйдёт больше времени, чем суммарно потратят таймеры на сдвиг всех оставшихся серий)
Если говорить только о сериях MLP, то наверняка так, но это не повод не делать: дело не в абсолютных затратах времени, а в задержках.
1:04 nwb: Автоматизируя, мы переносим затраты времени из той части процесса, которая вызывает задержки с созданием перевода в ту часть, которая не приводит к задержкам.
1:14 nwb: "Весенняя тренировка была потрясной," - я прочитал только первую строчку Докторов и уже мне похорошело. Они не отличают sprint от spring, и ничего у них не шевельнулось, что "весна" по контексту не подходит...
1:25 Wolfram: >Если говорить только о сериях MLP, то наверняка так, но это не повод не делать: дело не в абсолютных затратах времени, а в задержках.
Это я понимаю, но задержки из-за сдвигов тайминга незначительные, и это явно не то, чем нужно заниматься в первую очередь. Те же вставка тайминга в пад, где уже переводят, и возвращение плеера выглядят более перспективными и важными задачами. Зато автошифт тайминга выглядит как труЪ интеллектуальный челлендж)

==== Пад ====
Wolfram: Окей, можно так: события должны идти в одном и том же порядке в обоих рипах [накладывающиеся события объединяем в единые куски]. Значит, если внезапно в результате работы вышенаписанного алгоритма очередное событие K вставилось левее предыдущего (по левому концу смотрим), то это значит, что мы что-то перепутали.
Тут могут быть два случая [на самом деле, если будут тройные повторения, идущие сразу после рекламы, то всё будет в 100 раз хуже, но можно пренебречь]:
1) для события M<K было два похожих куска, и мы выбрали поздний, хотя должны были выбрать ранний. В результате когда мы дошли до K, для него уже не оказалось достаточно похожих после, а в результате капитальной сверки со всей аудиодорожкой больше всего подошёл ранний кусок. Разбираемся так: Находим первое уже подвинутое событие M<K такое, что по таймингу левого конца оно после K. События [M, K-1] пытаемся вставить в отрезок времени между левым концом M-1 и правым концом K рекурсивным вызовом функции сдвига тайминга. Если не получилось, значит, это не наш случай.

u0: Кажется, в таком случае не сработает: http://i.imgur.com/H4DfuxV.png

Wolfram: Так, я перестал понимать, как у нас M-2 оказалось на месте M-1? Они же должны быть очень похожи для этого.

u0: Ну вот так получилось. Может, шум сражения замусорил спектрограмму.

Wolfram: Ну я всё же полагаю, что если в шуме сражения можно разобрать, что говорится, то эти куски будут достаточно различаться, чтобы их нельзя было перепутать, но я могу и ошибаться, конечно.

u0: А если говорится одно и то же? Может, даже одна запись голоса актрисы вставлена два раза.

Wolfram: 2) Для события K был более ранний очень похожий на него момент, но на самом деле оно должно идти позже. Поняв, что первый случай не подошёл, пытаемся вставить события после K в зазор после левого конца K-1 рекурсивным вызовом.
Алгоритм возвращает, что у нас ничего не получилось, когда лучшее отклонение для какого-то события превышает установленный нами порог.

Wolfram: Ещё некоторые мысли по этому поводу. В субботу я написал программу для сравнения содержания англосаба в паде с англосабом в аегисабе (в перспективе я хочу использовать это для вставки точного тайминга). Оказалось, что это совсем несложно сделать, чтобы работало приемлемое время даже на Питоне (на самом деле я ещё как следует не оттестил, так что возможно вывод преждевременный, в транскрипте и аегисе расхождений будет гораздо больше, чем тут, а время работы алгоритма пропорционально их количеству). Основывался я на следующем алгоритме для сравнения последовательностей: https://publications.mpi-cbg.de/Wu_1990_6334.pdf
Алгоритм не работает в нашем случае, т.к. он заточен под одну-единственную функцию цены перехода от одной строке к другой. А именно, разрешено только удалять и вставлять символы, и цена каждой такой операции 1. Но основная идея этого алгоритма в том, что если последовательности различаются не сильно, то нам не обязательно обходить всю матрицу, мы можем оставаться недалеко от главной диагонали. И эта идея может сработать и в случае, когда цена перехода устроена гораздо более сложно, что и происходит в случае со звукодорожками.

u0: Насколько я помню, ключевой момент в алгоритме Майерса — то, что стоимости диагоналей в точности равны нулю. А оставаться недалеко от главной диагонали — оптимизация, которую можно применить к любому алгоритму, в том числе Needleman–Wunsch.

u0: В идеале хотелось бы получить алгоритм, справляющийся со следующими задачами:
1. Ретайминг между склеенным двухсерийником и отдельными сериями (и наоборот).
2. Ретайминг между полуторачасовой версией фильма для кинотеатров и трёхчасовой режиссёрской версией.
3. Ретайминг экранки со смехом в зале и попкорном.

Wolfram: [да, смех это проблема]

Wolfram: Хм....... Идея!
Пусть есть два аудиофайла (рипа), полученные друг из друга небольшим числом разрезов и сдвигов кусков (пространства между сдвинутыми кусками заполнены чем угодно) и добавлением небольшого шума. Разобьём их на отрезки по 0.001сек (далее будем называть эту величину времени тиком, разумеется, можно взять и другую). Для любого тика, не попавшего под разрез (а попавших под разрез очень мало, так что на них не особо важно, что происходит), есть "истинный сдвиг" - то, насколько был сдвинут кусок аудио, куда этот тик попал. Назовём целочисленный в тиках сдвиг разумным, если он отличается от истинного не более, чем на 1 тик.
Теперь введём следующую функцию F(int, int)->bool. Пусть A и B - два числа, номера тиков в первой и второй аудиодорожках соответсвенно. Мы требуем, чтобы 1) F(A, B)=False, только если эти два тика не соответствуют друг другу при разумном сдвиге тайминга, а F(A, B)=True может быть когда угодно, но если мы возьмём два рандомных тика, то 2) с довольно заметной вероятностью (ну там хоть 5%) F(A, B)=False.
Как можно построить такую функцию? Ну например рассмотреть N тиков (пусть N=5) левее A, N тиков правее A, и усреднить громкость по всем одиннадцати тикам. Аналогично для B. Ну или построить своеобразные спектрограммы этих участков для большей точности.

	u0: Громкость может отличаться на разных записях, и нормализовать её может быть сложно, если они разной продолжительности. Я бы попробовал в качестве расстояния cosine similarity.

	Wolfram: Можно, тут экспериментировать надо. Хотя вообще проблема в следующем: пусть звук у нас - синусоидальная волна с периодом 1 тик, а сдвиг - полтика, тогда полученное при сдвиге с точки зрения cosine similarity будет максимально далеко, а мы хотим, чтобы при малых сдвигах расстояние было небольшим. С громкостью такой проблемы не происходит. Можно попробовать перейти в зону частот (разложить в ряд Фурье) и сравнивать модули коэффициентов, они не меняются при сдвигах

Wolfram: После чего положить F(A, B)=False, если разность (громкостей/спектрограмм с как-то введённым расстоянием) превосходит некоторое пороговое значение. Свойство 1) должно выполняться, т.к. при сдвигах на значения, не превосходящие 1 тика, и добавлении мелких шумов (разница в рипах при разумных сдвигах должна быть устроена именно так) средняя громкость на 2N+1 тиках изменится не сильно, как и спектрограмма, так что наша функция обязана вернуть True. 

u0: Если это не экранка.

Wolfram: Свойство 2) будет выполняться, если мы возьмём не слишком большое пороговое значение.
Теперь как это нам поможет? Мы будем считать тики A и B из разных рипов похожими, если F(A, B)=True. А теперь применим O(NP) Sequence Comparison Algorithm, используя отношение похожести вместо равенства.

	u0: Не слишком ли много зависит от выбора порога? Не хотелось бы, чтобы нужно было для каждого случая подбирать его вручную.

	Wolfram: Порог можно попробовать подбирать автоматически, сравнивая друг с другом случайные участки и посчитав отклонения.

Wolfram: Время работы не будет превосходить O(общее число тиков в одном из рипов * число тиков, которое нужно добавить, чтобы скомпенсировать разные вырезки рекламы) [ой, если вырезана заставка, это будет долго... но этот случай можно отдельно обрабатывать как-нибудь] По свойству 2) и исходя из того, что при сдвиге на 2N+1 тиков и более все соответствия действительно случайны, это значит, что в результате работы O(NP) не могут получиться длинные куски с соответствием тайминга, ошибочным более чем на 2N+1. 

	u0: Зависит от выбора продолжительности тика. На расстоянии 11 мс, например, может получиться очень много совпадений.

	Wolfram: Ну фиг знает, надо экспериментировать, но ошибка в сдвиге тайминга на 11мс во всяком случае не критична.

Wolfram: А если будет много коротких кусков с сильно неправильными сдвигами, между любыми двумя короткими придётся шаманить добавлением тиков, что будет дороже, чем сделать всё правильно, как я предполагаю, поэтому O(NP)-алгоритм должен вернуть почти точное соответствие.

u0: А если просто применить к этой матрице алгоритм Дейкстры, не получится то же самое O(ND)?

Wolfram: По-моему получится, но Дейкстра больше памяти жрёт, наверное.

u0: Ага.

Wolfram: А если применить A* с эвристикой "расстояние не меньше, чем горизонтальное/вертикальное расстояние до нужной диагонали", то очень похоже на O(NP) получается по времени работы.

u0: Это избавило бы от необходимости сводить разницу между тиками к бинарному отношению похож-непохож. И да, я сначала не обратил внимания, но O(NP) действительно намного лучше O(ND).

Wolfram: Можно сделать так: вертикальные и горизонтальные рёбра имеют цену 1, а все диагональные имеют цену от 0 до 1 в зависимости от степени похожести. Проходимся астаром с оценкой, что расстояние между точками не меньше вертикального расстояния между диагоналями. Главное - выбрать функцию похожести так, чтобы при правильном сопоставлении диагонали давали очень маленький вклад в цену, тогда мы действительно не сильно отклонимся при поиске от главной диагонали.

u0: У этого алгоритма нелинейный расход памяти, и трюк с делением пополам (как в Hirschberg's algorithm) не спасает. 

	Wolfram: Да, это так, расход памяти порядка O(ND) получается, если хранить все вершины. Этого навряд ли хватит для файлов длины 22 минуты и тика 0.001сек. Но, видится мне, чтобы получить только цену, без искомой цепочки преобразований, для A* при обходе ациклического графа нужно хранить только "фронт" - не до конца обследованные вершины, - а их количество будет не так велико (в худшем случае, полагаю, таки нелинейно [Wolfram: хотя хз, может ли быть много фронтовых вершин на одной диагонали? u0: В том и дело, что в общем случае может. Wolfram: Ну ок, на одной диагонали я пример ещё смогу как-то привести, но вот чтобы одновременно на многих? Если это и случается, то не очень часто, как мне кажется. u0: Может быть. Вполне возможно, что на практике расход памяти не будет проблемой.], но это явно лучше, чем хранить всё). А если мы умеем получать цену, то можно попробовать как-то модифицировать трюк с делением пополам. Точно как в Hirschberg's algorithm это не пройдёт, ибо мы не можем себе позволить получить всю последнюю строку таблицы.
	Собственно, можно сделать так. При прохождении A* запоминаем среднее сечение таблицы, т.е. расстояния от первой половины X до всевозможных кусков Y, которым эта половина может соответствовать при оптимальном прохождении. [u0: Но А* не заполняет средний столбец целиком. Wolfram: Разве он не заполнит все ячейки, по которым проходят оптимальные маршруты? u0[перечёркнуто]: А если дожидаться, пока заполнит, это займёт квадратичное время. Wolfram: В общем, я утверждаю, что если мы рассмотрим произвольный оптимальный маршрут, и посмотрим, в какой ячейке он пересекает средний столбец, то эту ячейку заполнят как прямой, так и обратный A*. А значит, пройдя по всем ячейкам столбца, которые заполнят оба, и найдя ту, где сумма расстояний до концов совпадает с найденной ценой, мы найдём искомое разбиение. u0: Да, похоже, что всё правильно.] На это потребуется дополнительно линейное число памяти. Далее запускаем ещё один A* задом наперёд: разворачиваем все рёбра графа и начинаем из противоположного угла. Так мы узнаем все расстояния от второй половины X до всевозможных разумных кусков Y. Дальше проходимся по Y, и смотрим, при каком его разбиении сумма расстояний какая надо.

u0: В алгоритме Майерса (в отличие от A*) в каждый момент времени для каждой диагонали хранится только одно значение — одна из координат точки, стоимость пути к которой равна текущему значению d. Я пока не вижу, как сохранить и это свойство, и ненулевые стомости диагональных рёбер.

u0: У меня были такие мысли.
1. Искомый путь состоит из очень небольшого числа непрерывных горизонтальных, вертикальных или диагональных цепочек. Редко больше пяти.
2. Это можно использовать, присвоив стоимость не только рёбрам, но и переходам между рёбрами разных типов. Например, рёбра имеют стоимость от 0 до 1, а переход с диагонального ребра на горизонтальное — стоимость 300. Это позволит существенно сузить множество рассматриваемых путей.
3. Мы также можем узнать, на каких именно диагоналях находятся длинные диагональные цепочки, посчитав кросс-корреляцию спектрограмм с помощью FFT (для каждой частоты получится своя кросс-корреляция, их можно просто усреднить). Пики на графике кросс-корреляции будут координатами нужных диагоналей.
4. Если предположить, что все цепочки достаточно длинные, то все диагональные цепочки лежат на найденных диагоналях. В этом случае можно поступить совсем грубо: попытаться состыковать соседние диагонали исключительно с помощью непрерывных горизонтальных или вертикальных цепочек. Но если мы стремимся к универсальности, то лучше такого не предполагать.(*)
5. Можно как-нибудь обработать эти диагонали для ускорения последующего поиска. Например, для каждой точки посчитать длину гарантированно выгодного диагонального скачка: максимальную длину диагональной цепочки, начинающейся в этой точке, стоимость которой не превышает стоимость перехода на вертикальное или горизонтальное ребро.

Wolfram: Сомнительная выгода, ибо где-то в середине этой длинной диагональной цепочки в оптимальном маршруте может быть смещение по горизонтали на другую диагональ.

u0: А может и не быть. Нам всё равно придётся пройтись по этой цепочке, но так мы будем идти по одному ребру за шаг, а так большую её часть пройдём скачками по 1000 (например) рёбер. Да, последний скачок будет слишком длинным, и позже придётся вернуться к предыдущей точке (которая всё ещё будет частью фронта), но без этой оптимизации во фронте, скорее всего, окажутся вообще все точки этой цепочки, а не одна из 1000.

Wolfram: Ну я пока не вижу способа проверять, являлся ли какой-то скачок длинным, не проходя все точки по-честному. В смысле, какой граф мы хотим рассматривать и почему при его обходе фронт будет меньше?

u0: Граф, который я хотел рассматривать, — та же сетка с горизонтальными, вертикальными и диагональными рёбрами, но дополненная длинными диагональными рёбрами. Это позволило бы сократить количество рёбер в оптимальном пути в несколько раз. Но, похоже, ты прав: сокращение количества рёбер не помогает сократить время поиска.

u0: 6. Можно попробовать обойтись без трюка с делением пополам, а просто хранить весь путь в каждой точке фронта. Это займёт O(количество цепочек * размер фронта) памяти.

Wolfram: Мы диагонально ходим только по выделенным на шаге 3 цепочкам? Если да, тогда нам вообще можно рассмотреть граф с вершинами только на них и вертикальными и горизонтальными рёбрами очень большого веса между вершинами одного уровня соседних цепочек. В нём будет O(количество цепочек * N) вершин, так что мы можем хранить хоть всего Дейкстру.

u0: В пункте 4 я имел в виду именно это, но в пункте 6 это не обязательно.

Wolfram: Если нет, то я не понял, почему первый множитель (длина пути) в асимптотике такой мелкий.

u0: Цепочки могут быть где угодно, главное, что их мало. Я предлагаю искусственно ограничить количество цельных горизонтальных/вертикальных/диагональных цепочек. 

	Wolfram: Ну так а как мы этого добьёмся? Вот мы в какой-то момент достигли предела изломов. И что дальше с этой вершиной делать, тупо идти по диагонали? Ну так это может оказаться значительно менее оптимально в итоге, чем если бы мы не жадничали в начале по цене, а сделали чуть меньше изломов.

	u0: Предполагается, что мы знаем, что на самом деле в аудиодорожках было не более Т разрезов. Если, несмотря на высокую стоимость излома, в оптимальном пути к некоторой точке матрицы их оказалось более (Т+1) — значит, что-то с нашими параметрами не так. Нужно либо отчитаться о неудаче, либо попробовать ещё раз, удвоив стоимость излома.

	Wolfram: Окей, так можно.

u0: Тогда в каждом узле достаточно будет хранить список стыков (переходов между рёбрами разных типов) в оптимальной цепочке, ведущей к этому узлу.

Wolfram: (*)Ну вообще если мы стремимся к универсальности, то и назначать какую-то фиксированную стоимость перехода с горизонтали на вертикаль не стоит, ибо в общем случае мы не знаем, насколько мелко может быть нарезано. 

	u0: Я не знаю, есть ли реалистичная ситуация, когда нарезано может быть действительно мелко. Кроме того, скорость сравнения дорожек человеком определяется в первую очередь количеством стыков, а не D или P, так что такое ограничение будет хотя бы интуитивно понятно пользователю (если сделать его настраиваемым параметром).

	Wolfram: Ок.

Wolfram: Как и определение пика в пункте 3 может оказаться в общем случае не так-то просто дать, особенно если есть повторяющиеся участки аудиодорожки. (Впрочем, если они дадут нам десяток лишних диагоналей, это не должно сильно помешать.) 
	
	u0: При определении пиков самое неприятное — это не повторяющиеся участки, а очень короткие добавленные/удалённые фрагменты. Из-за них может быть трудно решить, один это пик или два разных. 
	
	Wolfram: Насколько я понимаю, раз FFT считается за O(N log N) от количества точек, то и кросскореляция за столько же, поэтому мы можем рассмотреть вообще все возможные сдвиги (т.е. в стандартном случае кратные чему-то порядка 1/44100 секунды), а не только, например, кратные выбранному размеру тика. На таком подробном графике два пика, отстоящие больше, чем на 1-5 тиков, мы как-нибудь сможем задетектить, наверное, а большая точность нам вряд ли потребуется, ибо сдвиг на такие промежутки времени нечувствителен для человека (т.е. удалённый фрагмент времени настолько короткий, что можно считать, будто ничего и не удалялось)

	u0: Кросс-корреляцию имеет смысл считать только для величин, произведение (или квадрат разности) которых является хорошей мерой разницы между двумя моментами на аудиодорожке. Для исходных семплов это не так. Я думал использовать для этих целей либо спектрограмму, либо mel-scale filterbanks (та же спектрограмма, но в другом масштабе). Но спектрограмма — достаточно гладкая функция, на расстоянии 1 мс разницы почти нет.

Wolfram: Но конкретно в задаче сдвига тайминга, а не полномасштабного сравнения звукодорожек, 2-4 может оказаться весьма полезными эвристиками.
